<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radial Piano - Experimental</title>
    <style>
        /* ============================================
           CSS VARIABLES & RESET
           ============================================ */
        :root {
            --bg-primary: #2e2e2e;
            --slice-color: #000;
            --accent-color: #007bff;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background: var(--bg-primary);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        body {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            width: 100dvw;
        }

        /* ============================================
           LAYOUT & STRUCTURE
           ============================================ */
        .main-content {
            width: 100%;
            height: 100%;
            position: relative;
            background: var(--bg-primary);
        }

        .radial-piano {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
        }

        .slice {
            stroke: none;
            cursor: pointer;
        }

        .slice:focus {
            outline: none;
        }

        /* ============================================
           MODAL & CONTROLS
           ============================================ */
        .modal-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop.active {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            padding: 30px;
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #666;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #e0e0e0;
            color: #333;
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: 24px;
            color: #333;
            font-size: 20px;
        }

        .toggle-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 56px;
            height: 56px;
            background: #333;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 50;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toggle-controls:hover {
            background: #555;
            transform: translateX(-50%) scale(1.1);
        }

        .toggle-controls.active {
            background: var(--accent-color);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }

        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        .control-group input[type="range"] {
            margin-bottom: 5px;
        }

        .range-value {
            text-align: center;
            font-size: 14px;
            color: #666;
            background: #f5f5f5;
            padding: 4px 10px;
            border-radius: 4px;
            display: inline-block;
            min-width: 45px;
        }

        .number-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .number-input input {
            flex: 1;
            text-align: center;
        }

        .stepper-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #e0e0e0;
            background: #f8f8f8;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            transition: all 0.2s ease;
        }

        .stepper-btn:hover {
            border-color: #ccc;
            background: #f0f0f0;
        }
    </style>
</head>
<body>
    <button class="toggle-controls" id="toggleBtn" aria-label="Open controls">âš™</button>

    <div class="modal-backdrop" id="modalBackdrop">
        <div class="modal-content" id="modalContent">
            <button class="modal-close" id="closeBtn" aria-label="Close controls">âœ•</button>

            <h3>Radial Piano Controls</h3>

            <div class="control-group">
                <label for="sliceCount">Number of Slices:</label>
                <div class="number-input">
                    <button class="stepper-btn" id="sliceDecBtn" aria-label="Decrease slices">âˆ’</button>
                    <input type="number" id="sliceCount" value="32" min="6" max="72" aria-label="Number of slices">
                    <button class="stepper-btn" id="sliceIncBtn" aria-label="Increase slices">+</button>
                </div>
            </div>

            <div class="control-group">
                <label for="bgGraySlider">Background Gray: <span class="range-value" id="bgGrayValue">18</span>%</label>
                <input type="range" id="bgGraySlider" min="0" max="100" value="18" aria-label="Background gray">
            </div>

            <div class="control-group">
                <label for="offsetXSlider">Offset X: <span class="range-value" id="offsetXValue">0</span>%</label>
                <input type="range" id="offsetXSlider" min="-100" max="100" value="0" aria-label="Horizontal offset">
            </div>

            <div class="control-group">
                <label for="offsetYSlider">Offset Y: <span class="range-value" id="offsetYValue">0</span>%</label>
                <input type="range" id="offsetYSlider" min="-100" max="100" value="0" aria-label="Vertical offset">
            </div>

            <div class="control-group">
                <label for="radiusSlider">Radius: <span class="range-value" id="radiusValue">100</span>%</label>
                <input type="range" id="radiusSlider" min="20" max="200" value="100" aria-label="Circle radius">
            </div>

            <div class="control-group">
                <label for="rotationSlider">Rotation: <span class="range-value" id="rotationValue">58</span>Â°</label>
                <input type="range" id="rotationSlider" min="0" max="359" value="58" aria-label="Circle rotation">
            </div>

            <div class="control-group">
                <label for="gapSizeSlider">Gap Size: <span class="range-value" id="gapSizeValue">0.2</span>Â°</label>
                <input type="range" id="gapSizeSlider" min="0" max="3" step="0.1" value="0.2" aria-label="Gap size">
            </div>

            <div class="control-group">
                <label for="gripThicknessSlider">Grip Thickness: <span class="range-value" id="gripThicknessValue">2</span>px</label>
                <input type="range" id="gripThicknessSlider" min="0.5" max="4" step="0.5" value="2" aria-label="Grip thickness">
            </div>

            <div class="control-group">
                <label for="ticksPerEdgeSlider">Ticks Per Edge: <span class="range-value" id="ticksPerEdgeValue">4</span></label>
                <input type="range" id="ticksPerEdgeSlider" min="0" max="20" step="1" value="4" aria-label="Ticks per edge">
            </div>

            <div class="control-group">
                <label for="gripOpacitySlider">Grip Opacity: <span class="range-value" id="gripOpacityValue">10</span>%</label>
                <input type="range" id="gripOpacitySlider" min="0" max="100" step="5" value="10" aria-label="Grip opacity">
            </div>

            <div class="control-group">
                <label for="gripRingOpacitySlider">Grip Ring Opacity: <span class="range-value" id="gripRingOpacityValue">5</span>%</label>
                <input type="range" id="gripRingOpacitySlider" min="0" max="100" step="5" value="5" aria-label="Grip ring opacity">
            </div>

            <div class="control-group">
                <label for="gripInsetSlider">Grip Inset: <span class="range-value" id="gripInsetValue">5</span>%</label>
                <input type="range" id="gripInsetSlider" min="0" max="50" step="5" value="5" aria-label="Grip inset">
            </div>

            <div class="control-group">
                <label for="pressShrinkSlider">Press Shrink: <span class="range-value" id="pressShrinkValue">2</span>%</label>
                <input type="range" id="pressShrinkSlider" min="0" max="20" step="1" value="2" aria-label="Press shrink">
            </div>

            <div class="control-group">
                <label for="pressBrightnessSlider">Press Brightness: <span class="range-value" id="pressBrightnessValue">30</span>%</label>
                <input type="range" id="pressBrightnessSlider" min="0" max="100" step="5" value="30" aria-label="Press brightness">
            </div>
        </div>
    </div>

    <div class="main-content">
        <svg class="radial-piano" id="pianoSvg" role="application" aria-label="Radial piano interface"></svg>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        'use strict';

        // ============================================
        // CONSTANTS & CONFIGURATION
        // ============================================
        const SVG_NS = 'http://www.w3.org/2000/svg';
        const RESIZE_DEBOUNCE_MS = 100;
        const INNER_CIRCLE_RADIUS_RATIO = 0.25;
        const DRAGGABLE_RING_RATIO = 0.6;
        const VIEWPORT_SAFETY_BUFFER = 1.2;
        const C_MAJOR_SCALE = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        const CORNER_COORDS = { 'bottom-right': { x: 100, y: 100 } };

        const INITIAL_STATE = {
            sliceCount: 32,
            bgGray: 18,
            offsetX: 0,
            offsetY: 0,
            radius: 100,
            rotation: 58,
            gapSize: 0.2,
            gripThickness: 2,
            gripOpacity: 10,
            ticksPerEdge: 4,
            gripRingOpacity: 5,
            gripInset: 5,
            pressShrink: 2,
            pressBrightness: 30
        };

        // ============================================
        // STATE MANAGER
        // ============================================
        class StateManager {
            constructor(initialState) {
                this._state = { ...initialState };
                this._listeners = new Map();
                this._computedCache = new Map();
            }

            get(key) {
                return this._state[key];
            }

            getAll() {
                return { ...this._state };
            }

            set(key, value) {
                if (this._state[key] !== value) {
                    this._state[key] = value;
                    this._computedCache.clear();
                    this._notify(key, value);
                }
            }

            subscribe(keys, callback) {
                const keyArray = Array.isArray(keys) ? keys : [keys];
                keyArray.forEach(key => {
                    if (!this._listeners.has(key)) {
                        this._listeners.set(key, new Set());
                    }
                    this._listeners.get(key).add(callback);
                });
                return () => {
                    keyArray.forEach(key => {
                        const listeners = this._listeners.get(key);
                        if (listeners) listeners.delete(callback);
                    });
                };
            }

            getComputed(key, computeFn) {
                if (!this._computedCache.has(key)) {
                    this._computedCache.set(key, computeFn(this._state));
                }
                return this._computedCache.get(key);
            }

            invalidateComputed() {
                this._computedCache.clear();
            }

            _notify(key, value) {
                const listeners = this._listeners.get(key);
                if (listeners) {
                    listeners.forEach(callback => callback(value, key));
                }
            }
        }

        // ============================================
        // GEOMETRY ENGINE
        // ============================================
        class GeometryEngine {
            constructor(stateManager) {
                this.state = stateManager;
            }

            getViewportSize() {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight
                };
            }

            calculateCenter() {
                return this.state.getComputed('center', (state) => {
                    const size = this.getViewportSize();
                    const base = CORNER_COORDS['bottom-right'];
                    const baseX = (base.x / 100) * size.width;
                    const baseY = (base.y / 100) * size.height;
                    const offsetXPixels = (state.offsetX / 100) * size.width;
                    const offsetYPixels = (state.offsetY / 100) * size.width;

                    return {
                        x: baseX + offsetXPixels,
                        y: baseY + offsetYPixels
                    };
                });
            }

            calculateRadii() {
                return this.state.getComputed('radii', (state) => {
                    const size = this.getViewportSize();
                    const center = this.calculateCenter();

                    const corners = [
                        { x: 0, y: 0 },
                        { x: size.width, y: 0 },
                        { x: 0, y: size.height },
                        { x: size.width, y: size.height }
                    ];

                    const maxDistance = Math.max(...corners.map(corner =>
                        Math.sqrt((corner.x - center.x) ** 2 + (corner.y - center.y) ** 2)
                    ));

                    const safeDistance = maxDistance * VIEWPORT_SAFETY_BUFFER;
                    const scaledRadius = (state.radius / 100) * safeDistance;

                    return { rx: scaledRadius, ry: scaledRadius };
                });
            }

            getRadiusAtAngle(angle, rx, ry) {
                const rad = angle * Math.PI / 180;
                const cosA = Math.cos(rad);
                const sinA = Math.sin(rad);
                return (rx * ry) / Math.sqrt((ry * cosA) ** 2 + (rx * sinA) ** 2);
            }

            createPathGenerator(center, radii, startAngle, endAngle) {
                const { rx, ry } = radii;
                const r1 = this.getRadiusAtAngle(startAngle, rx, ry);
                const r2 = this.getRadiusAtAngle(endAngle, rx, ry);
                const avgRadius = (r1 + r2) / 2;

                const startRad = (startAngle * Math.PI) / 180;
                const endRad = (endAngle * Math.PI) / 180;

                const originalPoints = {
                    x1: center.x + r1 * Math.cos(startRad),
                    y1: center.y + r1 * Math.sin(startRad),
                    x2: center.x + r2 * Math.cos(endRad),
                    y2: center.y + r2 * Math.sin(endRad)
                };

                return (narrowFactor = 1) => {
                    const midAngle = (startAngle + endAngle) / 2;
                    const midRad = (midAngle * Math.PI) / 180;

                    const x1 = originalPoints.x1 + (center.x + avgRadius * Math.cos(midRad) - originalPoints.x1) * (1 - narrowFactor);
                    const y1 = originalPoints.y1 + (center.y + avgRadius * Math.sin(midRad) - originalPoints.y1) * (1 - narrowFactor);
                    const x2 = originalPoints.x2 + (center.x + avgRadius * Math.cos(midRad) - originalPoints.x2) * (1 - narrowFactor);
                    const y2 = originalPoints.y2 + (center.y + avgRadius * Math.sin(midRad) - originalPoints.y2) * (1 - narrowFactor);

                    return `M ${center.x} ${center.y} L ${x1} ${y1} A ${avgRadius} ${avgRadius} 0 0 1 ${x2} ${y2} Z`;
                };
            }

            getAngleFromPoint(x, y, center) {
                const dx = x - center.x;
                const dy = y - center.y;
                return Math.atan2(dy, dx) * 180 / Math.PI;
            }

            isInDraggableRing(x, y, center, innerRadius) {
                const draggableRingStart = innerRadius * DRAGGABLE_RING_RATIO;
                const dx = x - center.x;
                const dy = y - center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance >= draggableRingStart && distance <= innerRadius;
            }

            getSliceIndexAtPoint(x, y, center, sliceCount) {
                const rotation = this.state.get('rotation');
                let angle = this.getAngleFromPoint(x, y, center);
                angle = (angle + 360) % 360;
                angle = (angle - rotation + 360) % 360;
                const anglePerSlice = 360 / sliceCount;
                return Math.floor(angle / anglePerSlice);
            }
        }

        // ============================================
        // AUDIO ENGINE
        // ============================================
        class AudioEngine {
            constructor() {
                this.synth = null;
                this.activeNotes = new Map(); // Maps index -> note
            }

            async init() {
                if (!this.synth) {
                    this.synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: {
                            attack: 0.05,
                            decay: 0.1,
                            sustain: 0.9,
                            release: 1
                        }
                    }).toDestination();
                    this.synth.volume.value = -10;
                }

                // Resume audio context for mobile browsers
                if (Tone.context.state !== 'running') {
                    await Tone.context.resume();
                    console.log('ðŸ”Š Audio context resumed');
                }
            }

            getNote(index) {
                const noteInScale = index % 7;
                const octave = 3 + Math.floor(index / 7);
                return C_MAJOR_SCALE[noteInScale] + octave;
            }

            async playNote(index) {
                await this.init();
                const note = this.getNote(index);
                if (!this.activeNotes.has(index)) {
                    console.log(`ðŸŽµ Playing note ${note} (index ${index}) - Context state: ${Tone.context.state}`);
                    this.synth.triggerAttack(note);
                    this.activeNotes.set(index, note);
                } else {
                    console.log(`â­ï¸ Note ${note} already playing (index ${index})`);
                }
            }

            stopNote(index) {
                if (this.activeNotes.has(index)) {
                    const note = this.activeNotes.get(index);
                    console.log(`ðŸ›‘ Stopping note ${note} (index ${index})`);
                    if (this.synth) {
                        this.synth.triggerRelease(note);
                    }
                    this.activeNotes.delete(index);
                } else {
                    console.log(`âš ï¸ Tried to stop note at index ${index} but it wasn't active`);
                }
            }

            stopAllNotes() {
                console.log(`ðŸ”‡ Stopping ALL notes. Active count: ${this.activeNotes.size}`);
                if (this.synth && this.activeNotes.size > 0) {
                    // Release each note individually
                    this.activeNotes.forEach((note, index) => {
                        console.log(`  - Releasing ${note} (index ${index})`);
                        this.synth.triggerRelease(note);
                    });
                }
                this.activeNotes.clear();
                console.log(`âœ… All notes cleared`);
            }
        }

        // ============================================
        // RENDER ENGINE
        // ============================================
        class RenderEngine {
            constructor(svgElement, stateManager, geometryEngine) {
                this.svg = svgElement;
                this.state = stateManager;
                this.geometry = geometryEngine;
                this.sliceElements = new Map();
                this.pathGenerators = new Map();
                this.sliceGroup = null;
                this.innerCircle = null;
            }

            updateViewBox() {
                const size = this.geometry.getViewportSize();
                this.svg.setAttribute('viewBox', `0 0 ${size.width} ${size.height}`);
            }

            clear() {
                this.svg.innerHTML = '';
                this.sliceElements.clear();
                this.pathGenerators.clear();
                this.sliceGroup = null;
                this.innerCircle = null;
            }

            renderBackground() {
                const size = this.geometry.getViewportSize();
                const bgRect = document.createElementNS(SVG_NS, 'rect');
                bgRect.setAttribute('x', '0');
                bgRect.setAttribute('y', '0');
                bgRect.setAttribute('width', size.width);
                bgRect.setAttribute('height', size.height);

                const grayValue = Math.round((this.state.get('bgGray') / 100) * 255);
                const hexValue = grayValue.toString(16).padStart(2, '0');
                bgRect.setAttribute('fill', `#${hexValue}${hexValue}${hexValue}`);
                bgRect.style.pointerEvents = 'none';

                this.svg.appendChild(bgRect);
            }

            createSliceGroup() {
                const center = this.geometry.calculateCenter();
                const rotation = this.state.get('rotation');

                this.sliceGroup = document.createElementNS(SVG_NS, 'g');
                this.sliceGroup.setAttribute('id', 'sliceGroup');
                this.sliceGroup.setAttribute('transform', `rotate(${rotation} ${center.x} ${center.y})`);

                const defs = document.createElementNS(SVG_NS, 'defs');
                this.sliceGroup.appendChild(defs);

                return defs;
            }

            createGradient(defs, index, center, radii, anglePerSlice) {
                const midAngle = ((index + 0.5) * anglePerSlice) * Math.PI / 180;
                const r = Math.max(radii.rx, radii.ry);

                const x2 = center.x + r * Math.cos(midAngle);
                const y2 = center.y + r * Math.sin(midAngle);

                const gradient = document.createElementNS(SVG_NS, 'linearGradient');
                gradient.setAttribute('id', `gradient${index}`);
                gradient.setAttribute('x1', center.x);
                gradient.setAttribute('y1', center.y);
                gradient.setAttribute('x2', x2);
                gradient.setAttribute('y2', y2);
                gradient.setAttribute('gradientUnits', 'userSpaceOnUse');

                const stop1 = document.createElementNS(SVG_NS, 'stop');
                stop1.setAttribute('offset', '0%');
                stop1.setAttribute('stop-color', '#000');

                const stop2 = document.createElementNS(SVG_NS, 'stop');
                stop2.setAttribute('class', `stop2-${index}`);
                stop2.setAttribute('offset', '100%');
                stop2.setAttribute('stop-color', '#000');

                gradient.appendChild(stop1);
                gradient.appendChild(stop2);
                defs.appendChild(gradient);
            }

            createSlice(index, center, radii, anglePerSlice) {
                const gapSize = this.state.get('gapSize');
                const sliceCount = this.state.get('sliceCount');

                const startAngle = (index * anglePerSlice) + (gapSize / 2);
                const endAngle = ((index + 1) * anglePerSlice) - (gapSize / 2);

                const pathGenerator = this.geometry.createPathGenerator(center, radii, startAngle, endAngle);
                this.pathGenerators.set(index, pathGenerator);

                const slice = document.createElementNS(SVG_NS, 'path');
                slice.setAttribute('d', pathGenerator(1));
                slice.setAttribute('class', 'slice');
                slice.setAttribute('fill', `url(#gradient${index})`);
                slice.setAttribute('data-slice', index);
                slice.setAttribute('tabindex', '0');
                slice.setAttribute('role', 'button');
                slice.setAttribute('aria-label', `Slice ${index + 1} of ${sliceCount}`);

                this.sliceElements.set(index, slice);
                return slice;
            }

            renderSlices() {
                const center = this.geometry.calculateCenter();
                const radii = this.geometry.calculateRadii();
                const sliceCount = this.state.get('sliceCount');
                const anglePerSlice = 360 / sliceCount;

                const defs = this.createSliceGroup();

                // Create gradients and slices
                const fragment = document.createDocumentFragment();
                for (let i = 0; i < sliceCount; i++) {
                    this.createGradient(defs, i, center, radii, anglePerSlice);
                    fragment.appendChild(this.createSlice(i, center, radii, anglePerSlice));
                }

                this.sliceGroup.appendChild(fragment);
                this.svg.appendChild(this.sliceGroup);
            }

            renderInnerCircle() {
                const center = this.geometry.calculateCenter();
                const radii = this.geometry.calculateRadii();
                const avgRadius = (radii.rx + radii.ry) / 2;
                const innerRadius = avgRadius * INNER_CIRCLE_RADIUS_RATIO;

                this.innerCircle = document.createElementNS(SVG_NS, 'circle');
                this.innerCircle.setAttribute('cx', center.x);
                this.innerCircle.setAttribute('cy', center.y);
                this.innerCircle.setAttribute('r', innerRadius);
                this.innerCircle.setAttribute('fill', 'transparent');
                this.innerCircle.setAttribute('stroke', '#fff');
                this.innerCircle.setAttribute('stroke-width', '0');
                this.innerCircle.setAttribute('id', 'innerRotationPlate');
                this.innerCircle.style.cursor = 'grab';
                this.innerCircle.style.pointerEvents = 'all';

                this.sliceGroup.appendChild(this.innerCircle);
                return innerRadius;
            }

            renderGripRing(innerRadius) {
                const center = this.geometry.calculateCenter();
                const gripRingRadius = innerRadius * DRAGGABLE_RING_RATIO;
                const gripRingOpacity = this.state.get('gripRingOpacity');

                const gripRing = document.createElementNS(SVG_NS, 'circle');
                gripRing.setAttribute('cx', center.x);
                gripRing.setAttribute('cy', center.y);
                gripRing.setAttribute('r', (gripRingRadius + innerRadius) / 2);
                gripRing.setAttribute('fill', 'none');
                gripRing.setAttribute('stroke', '#fff');
                gripRing.setAttribute('stroke-width', innerRadius - gripRingRadius);
                gripRing.setAttribute('opacity', gripRingOpacity / 100);
                gripRing.style.pointerEvents = 'none';

                this.sliceGroup.appendChild(gripRing);
                return gripRingRadius;
            }

            renderGripTicks(innerRadius, gripRingRadius) {
                const center = this.geometry.calculateCenter();
                const sliceCount = this.state.get('sliceCount');
                const ticksPerEdge = this.state.get('ticksPerEdge');
                const gripThickness = this.state.get('gripThickness');
                const gripOpacity = this.state.get('gripOpacity');
                const gripInset = this.state.get('gripInset');

                const totalTicks = sliceCount * ticksPerEdge;
                const gripRingWidth = innerRadius - gripRingRadius;
                const insetAmount = (gripInset / 100) * gripRingWidth;
                const innerTickRadius = gripRingRadius + insetAmount;
                const outerTickRadius = innerRadius - insetAmount;

                const fragment = document.createDocumentFragment();
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i / totalTicks) * 360;
                    const angleRad = (angle * Math.PI) / 180;

                    const x1 = center.x + innerTickRadius * Math.cos(angleRad);
                    const y1 = center.y + innerTickRadius * Math.sin(angleRad);
                    const x2 = center.x + outerTickRadius * Math.cos(angleRad);
                    const y2 = center.y + outerTickRadius * Math.sin(angleRad);

                    const tick = document.createElementNS(SVG_NS, 'line');
                    tick.setAttribute('x1', x1);
                    tick.setAttribute('y1', y1);
                    tick.setAttribute('x2', x2);
                    tick.setAttribute('y2', y2);
                    tick.setAttribute('stroke', '#fff');
                    tick.setAttribute('stroke-width', gripThickness);
                    tick.setAttribute('opacity', gripOpacity / 100);
                    tick.style.pointerEvents = 'none';

                    fragment.appendChild(tick);
                }

                this.sliceGroup.appendChild(fragment);
            }

            renderNoteMarkers(innerRadius) {
                const center = this.geometry.calculateCenter();
                const sliceCount = this.state.get('sliceCount');
                const anglePerSlice = 360 / sliceCount;

                const fragment = document.createDocumentFragment();
                for (let i = 0; i < sliceCount; i++) {
                    if (i % 7 === 0) {
                        const midAngle = ((i + 0.5) * anglePerSlice) * Math.PI / 180;
                        const markerRadius = innerRadius * 1.08;

                        const markerX = center.x + markerRadius * Math.cos(midAngle);
                        const markerY = center.y + markerRadius * Math.sin(midAngle);

                        const marker = document.createElementNS(SVG_NS, 'circle');
                        marker.setAttribute('cx', markerX);
                        marker.setAttribute('cy', markerY);
                        marker.setAttribute('r', '4');
                        marker.setAttribute('fill', '#999');
                        marker.style.pointerEvents = 'none';

                        fragment.appendChild(marker);
                    }
                }

                this.sliceGroup.appendChild(fragment);
            }

            render() {
                this.updateViewBox();
                this.clear();
                this.renderBackground();
                this.renderSlices();
                const innerRadius = this.renderInnerCircle();
                const gripRingRadius = this.renderGripRing(innerRadius);
                this.renderGripTicks(innerRadius, gripRingRadius);
                this.renderNoteMarkers(innerRadius);
            }

            updateRotation() {
                if (this.sliceGroup) {
                    const center = this.geometry.calculateCenter();
                    const rotation = this.state.get('rotation');
                    this.sliceGroup.setAttribute('transform', `rotate(${rotation} ${center.x} ${center.y})`);
                }
            }

            getPressColor() {
                const brightness = this.state.get('pressBrightness');
                const value = Math.round((brightness / 100) * 255);
                const hex = value.toString(16).padStart(2, '0');
                return `#${hex}${hex}${hex}`;
            }

            getPressNarrowFactor() {
                return 1 - (this.state.get('pressShrink') / 100);
            }

            pressSlice(index) {
                const stop2 = document.querySelector(`.stop2-${index}`);
                if (stop2) {
                    stop2.style.transition = 'stop-color 120ms cubic-bezier(0.4, 0.0, 0.2, 1)';
                    stop2.setAttribute('stop-color', this.getPressColor());
                }

                const slice = this.sliceElements.get(index);
                const pathGen = this.pathGenerators.get(index);
                if (slice && pathGen) {
                    slice.style.transition = 'd 120ms cubic-bezier(0.4, 0.0, 0.2, 1)';
                    slice.setAttribute('d', pathGen(this.getPressNarrowFactor()));
                }
            }

            releaseSlice(index) {
                const stop2 = document.querySelector(`.stop2-${index}`);
                if (stop2) {
                    stop2.style.transition = 'stop-color 300ms ease-out';
                    stop2.setAttribute('stop-color', '#000');
                }

                const slice = this.sliceElements.get(index);
                const pathGen = this.pathGenerators.get(index);
                if (slice && pathGen) {
                    slice.style.transition = 'd 300ms ease-out';
                    slice.setAttribute('d', pathGen(1));
                }
            }

            getSliceElement(index) {
                return this.sliceElements.get(index);
            }

            getInnerCircleData() {
                const center = this.geometry.calculateCenter();
                const radii = this.geometry.calculateRadii();
                const avgRadius = (radii.rx + radii.ry) / 2;
                const innerRadius = avgRadius * INNER_CIRCLE_RADIUS_RATIO;
                return { center, innerRadius };
            }
        }

        // ============================================
        // INTERACTION MANAGER
        // ============================================
        class InteractionManager {
            constructor(svgElement, stateManager, geometryEngine, renderEngine, audioEngine) {
                this.svg = svgElement;
                this.state = stateManager;
                this.geometry = geometryEngine;
                this.renderer = renderEngine;
                this.audio = audioEngine;

                this.dragState = {
                    isDragging: false,
                    isRotating: false,
                    isPinching: false,
                    pressedSlices: new Set(),
                    lastAngle: 0,
                    lastRotationSlice: null,
                    wasInGripperZone: false,
                    startedFromSlice: false,
                    lastTouchedSlice: null,
                    lastPinchDistance: 0
                };

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Slice interactions
                this.svg.addEventListener('mousedown', (e) => this.handleStart(e));
                this.svg.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });

                // Global movement and release
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                document.addEventListener('mouseup', () => this.handleEnd());
                document.addEventListener('touchend', () => this.handleEnd());
                document.addEventListener('touchcancel', () => this.handleEnd());

                // Keyboard support
                this.svg.addEventListener('keydown', (e) => this.handleKeyboard(e));
            }

            getSVGCoordinates(clientX, clientY) {
                const rect = this.svg.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                const viewBox = this.svg.viewBox.baseVal;
                const scaleX = viewBox.width / rect.width;
                const scaleY = viewBox.height / rect.height;
                return { x: x * scaleX, y: y * scaleY };
            }

            getTouchDistance(touch1, touch2) {
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            handleStart(e) {
                // Check for multi-touch (pinch gesture)
                // Only enable pinch if BOTH touches are in the gripper area
                if (e.touches && e.touches.length >= 2) {
                    const touch1Coords = this.getSVGCoordinates(e.touches[0].clientX, e.touches[0].clientY);
                    const touch2Coords = this.getSVGCoordinates(e.touches[1].clientX, e.touches[1].clientY);
                    const innerCircleData = this.renderer.getInnerCircleData();

                    const touch1InGripper = this.geometry.isInDraggableRing(touch1Coords.x, touch1Coords.y, innerCircleData.center, innerCircleData.innerRadius);
                    const touch2InGripper = this.geometry.isInDraggableRing(touch2Coords.x, touch2Coords.y, innerCircleData.center, innerCircleData.innerRadius);

                    if (touch1InGripper && touch2InGripper) {
                        this.startPinch(e.touches[0], e.touches[1]);
                        e.preventDefault();
                        return;
                    }
                    // Otherwise fall through to allow multi-touch on slices
                }

                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                const { x, y } = this.getSVGCoordinates(clientX, clientY);

                const innerCircleData = this.renderer.getInnerCircleData();
                const isInnerCircle = e.target.id === 'innerRotationPlate';
                const inDraggableRing = this.geometry.isInDraggableRing(x, y, innerCircleData.center, innerCircleData.innerRadius);

                if (isInnerCircle && inDraggableRing) {
                    this.startRotation(x, y, innerCircleData);
                    e.preventDefault();
                } else if (e.target.classList.contains('slice')) {
                    this.startSliceDrag(e.target);
                }
            }

            startPinch(touch1, touch2) {
                this.dragState.isPinching = true;
                this.dragState.lastPinchDistance = this.getTouchDistance(touch1, touch2);
                console.log('ðŸ¤ Pinch started, distance:', this.dragState.lastPinchDistance);
            }

            startRotation(x, y, innerCircleData) {
                this.dragState.isRotating = true;
                this.dragState.wasInGripperZone = true;
                this.dragState.startedFromSlice = false;
                this.dragState.lastAngle = this.geometry.getAngleFromPoint(x, y, innerCircleData.center);

                const innerCircle = document.getElementById('innerRotationPlate');
                if (innerCircle) innerCircle.style.cursor = 'grabbing';
            }

            startSliceDrag(sliceElement) {
                this.dragState.isDragging = true;
                this.dragState.startedFromSlice = true;
                const index = parseInt(sliceElement.getAttribute('data-slice'));
                this.activateSlice(index);
            }

            handleMove(e) {
                // Handle pinch gesture
                if (this.dragState.isPinching && e.touches && e.touches.length >= 2) {
                    this.handlePinch(e.touches[0], e.touches[1]);
                    e.preventDefault();
                    return;
                }

                // If we were pinching but now have less than 2 touches, reset pinch state
                // and transition to appropriate single-touch interaction
                if (this.dragState.isPinching && e.touches && e.touches.length < 2) {
                    console.log('ðŸ¤ â†’ â˜ï¸ Transition from pinch to single touch');
                    this.dragState.isPinching = false;
                    this.dragState.lastPinchDistance = 0;

                    // Determine what the remaining touch is over and set up appropriate state
                    const clientX = e.touches[0].clientX;
                    const clientY = e.touches[0].clientY;
                    const { x, y } = this.getSVGCoordinates(clientX, clientY);
                    const innerCircleData = this.renderer.getInnerCircleData();
                    const inGripperZone = this.geometry.isInDraggableRing(x, y, innerCircleData.center, innerCircleData.innerRadius);

                    if (inGripperZone) {
                        // Start rotation from gripper
                        this.dragState.isRotating = true;
                        this.dragState.wasInGripperZone = true;
                        this.dragState.lastAngle = this.geometry.getAngleFromPoint(x, y, innerCircleData.center);
                        const innerCircle = document.getElementById('innerRotationPlate');
                        if (innerCircle) innerCircle.style.cursor = 'grabbing';
                    } else {
                        // Check if over a slice and start dragging
                        const element = document.elementFromPoint(clientX, clientY);
                        if (element && element.classList && element.classList.contains('slice')) {
                            this.dragState.isDragging = true;
                            this.dragState.startedFromSlice = true;
                            const index = parseInt(element.getAttribute('data-slice'));
                            this.activateSlice(index);
                        } else {
                            // Not over anything specific, just mark as dragging to allow movement
                            this.dragState.isDragging = true;
                        }
                    }
                }

                if (!this.dragState.isDragging && !this.dragState.isRotating) return;

                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                const { x, y } = this.getSVGCoordinates(clientX, clientY);

                const innerCircleData = this.renderer.getInnerCircleData();
                const inGripperZone = this.geometry.isInDraggableRing(x, y, innerCircleData.center, innerCircleData.innerRadius);

                // Transition to rotation mode if entering gripper zone
                if (inGripperZone && !this.dragState.wasInGripperZone) {
                    // Release any currently touched slice when transitioning to rotation
                    if (this.dragState.lastTouchedSlice) {
                        const lastIndex = parseInt(this.dragState.lastTouchedSlice.getAttribute('data-slice'));
                        this.deactivateSlice(lastIndex);
                        this.dragState.lastTouchedSlice = null;
                    }

                    this.dragState.isRotating = true;
                    this.dragState.wasInGripperZone = true;
                    this.dragState.lastAngle = this.geometry.getAngleFromPoint(x, y, innerCircleData.center);
                    const innerCircle = document.getElementById('innerRotationPlate');
                    if (innerCircle) innerCircle.style.cursor = 'grabbing';
                }

                if (this.dragState.isRotating) {
                    this.handleRotation(x, y, innerCircleData);
                } else if (this.dragState.isDragging) {
                    this.handleSliceDrag(clientX, clientY);
                }

                e.preventDefault();
            }

            handlePinch(touch1, touch2) {
                const currentDistance = this.getTouchDistance(touch1, touch2);
                const distanceDelta = currentDistance - this.dragState.lastPinchDistance;

                // Sensitivity: ~20px change = 1 slice (more sensitive for smoother feel)
                const sliceChange = Math.round(distanceDelta / 20);

                if (sliceChange !== 0) {
                    const currentSliceCount = this.state.get('sliceCount');
                    // Pinch in (smaller distance) = MORE slices
                    // Expand out (larger distance) = FEWER slices
                    const newSliceCount = Math.max(6, Math.min(72, currentSliceCount - sliceChange));

                    if (newSliceCount !== currentSliceCount) {
                        console.log(`ðŸ¤ Pinch: ${currentSliceCount} â†’ ${newSliceCount} slices`);
                        this.state.set('sliceCount', newSliceCount);
                        this.renderer.render();
                        this.dragState.lastPinchDistance = currentDistance;
                    }
                }
            }

            handleRotation(x, y, innerCircleData) {
                const currentAngle = this.geometry.getAngleFromPoint(x, y, innerCircleData.center);
                let angleDiff = currentAngle - this.dragState.lastAngle;

                if (angleDiff > 180) angleDiff -= 360;
                if (angleDiff < -180) angleDiff += 360;

                const newRotation = (this.state.get('rotation') + angleDiff + 360) % 360;
                this.state.set('rotation', newRotation);
                this.dragState.lastAngle = currentAngle;

                if (this.dragState.startedFromSlice) {
                    this.activateSliceAtPosition(x, y, innerCircleData);
                }
            }

            handleSliceDrag(clientX, clientY) {
                const element = document.elementFromPoint(clientX, clientY);

                if (this.dragState.lastTouchedSlice && this.dragState.lastTouchedSlice !== element) {
                    const lastIndex = parseInt(this.dragState.lastTouchedSlice.getAttribute('data-slice'));
                    this.deactivateSlice(lastIndex);
                    this.dragState.lastTouchedSlice = null;
                }

                if (element && element.classList && element.classList.contains('slice')) {
                    const index = parseInt(element.getAttribute('data-slice'));
                    if (element !== this.dragState.lastTouchedSlice) {
                        this.activateSlice(index);
                        this.dragState.lastTouchedSlice = element;
                    }
                }
            }

            activateSliceAtPosition(x, y, innerCircleData) {
                const sliceIndex = this.geometry.getSliceIndexAtPoint(x, y, innerCircleData.center, this.state.get('sliceCount'));

                if (this.dragState.lastRotationSlice !== null && this.dragState.lastRotationSlice !== sliceIndex) {
                    this.deactivateSlice(this.dragState.lastRotationSlice);
                }

                if (sliceIndex !== this.dragState.lastRotationSlice) {
                    this.activateSlice(sliceIndex);
                    this.dragState.lastRotationSlice = sliceIndex;
                }
            }

            activateSlice(index) {
                this.renderer.pressSlice(index);
                const sliceElement = this.renderer.getSliceElement(index);
                if (sliceElement) {
                    this.dragState.pressedSlices.add(sliceElement);
                }
                this.audio.playNote(index);
            }

            deactivateSlice(index) {
                this.renderer.releaseSlice(index);
                const sliceElement = this.renderer.getSliceElement(index);
                if (sliceElement) {
                    this.dragState.pressedSlices.delete(sliceElement);
                }
                this.audio.stopNote(index);
            }

            handleEnd() {
                // Always stop all notes on any release event as a failsafe
                this.audio.stopAllNotes();

                if (this.dragState.isDragging || this.dragState.isRotating || this.dragState.isPinching) {
                    // Release all pressed slices
                    this.dragState.pressedSlices.forEach(slice => {
                        const index = parseInt(slice.getAttribute('data-slice'));
                        this.renderer.releaseSlice(index);
                    });

                    if (this.dragState.lastRotationSlice !== null) {
                        this.renderer.releaseSlice(this.dragState.lastRotationSlice);
                    }

                    // Reset drag state
                    this.dragState.isDragging = false;
                    this.dragState.isRotating = false;
                    this.dragState.isPinching = false;
                    this.dragState.wasInGripperZone = false;
                    this.dragState.startedFromSlice = false;
                    this.dragState.lastRotationSlice = null;
                    this.dragState.lastTouchedSlice = null;
                    this.dragState.lastPinchDistance = 0;
                    this.dragState.pressedSlices.clear();

                    const innerCircle = document.getElementById('innerRotationPlate');
                    if (innerCircle) innerCircle.style.cursor = 'grab';
                }
            }

            handleKeyboard(e) {
                if (e.target.classList.contains('slice') && (e.key === 'Enter' || e.key === ' ')) {
                    e.preventDefault();
                    const index = parseInt(e.target.getAttribute('data-slice'));
                    this.activateSlice(index);
                    setTimeout(() => this.deactivateSlice(index), 350);
                }
            }
        }

        // ============================================
        // CONTROLS MANAGER
        // ============================================
        class ControlsManager {
            constructor(stateManager, renderEngine) {
                this.state = stateManager;
                this.renderer = renderEngine;
                this.elements = this.getElements();
                this.setupEventListeners();
                this.syncUIWithState();
            }

            getElements() {
                return {
                    toggleBtn: document.getElementById('toggleBtn'),
                    closeBtn: document.getElementById('closeBtn'),
                    modalBackdrop: document.getElementById('modalBackdrop'),
                    sliceCount: document.getElementById('sliceCount'),
                    sliceDecBtn: document.getElementById('sliceDecBtn'),
                    sliceIncBtn: document.getElementById('sliceIncBtn'),
                    bgGraySlider: document.getElementById('bgGraySlider'),
                    bgGrayValue: document.getElementById('bgGrayValue'),
                    offsetXSlider: document.getElementById('offsetXSlider'),
                    offsetXValue: document.getElementById('offsetXValue'),
                    offsetYSlider: document.getElementById('offsetYSlider'),
                    offsetYValue: document.getElementById('offsetYValue'),
                    radiusSlider: document.getElementById('radiusSlider'),
                    radiusValue: document.getElementById('radiusValue'),
                    rotationSlider: document.getElementById('rotationSlider'),
                    rotationValue: document.getElementById('rotationValue'),
                    gapSizeSlider: document.getElementById('gapSizeSlider'),
                    gapSizeValue: document.getElementById('gapSizeValue'),
                    gripThicknessSlider: document.getElementById('gripThicknessSlider'),
                    gripThicknessValue: document.getElementById('gripThicknessValue'),
                    ticksPerEdgeSlider: document.getElementById('ticksPerEdgeSlider'),
                    ticksPerEdgeValue: document.getElementById('ticksPerEdgeValue'),
                    gripOpacitySlider: document.getElementById('gripOpacitySlider'),
                    gripOpacityValue: document.getElementById('gripOpacityValue'),
                    gripRingOpacitySlider: document.getElementById('gripRingOpacitySlider'),
                    gripRingOpacityValue: document.getElementById('gripRingOpacityValue'),
                    gripInsetSlider: document.getElementById('gripInsetSlider'),
                    gripInsetValue: document.getElementById('gripInsetValue'),
                    pressShrinkSlider: document.getElementById('pressShrinkSlider'),
                    pressShrinkValue: document.getElementById('pressShrinkValue'),
                    pressBrightnessSlider: document.getElementById('pressBrightnessSlider'),
                    pressBrightnessValue: document.getElementById('pressBrightnessValue')
                };
            }

            setupEventListeners() {
                // Modal controls
                this.elements.toggleBtn.addEventListener('click', () => this.toggleModal());
                this.elements.closeBtn.addEventListener('click', () => this.closeModal());
                this.elements.modalBackdrop.addEventListener('click', (e) => {
                    if (e.target === this.elements.modalBackdrop) this.closeModal();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.elements.modalBackdrop.classList.contains('active')) {
                        this.closeModal();
                    }
                });

                // Slice count controls
                this.elements.sliceDecBtn.addEventListener('click', () => this.changeSliceCount(-1));
                this.elements.sliceIncBtn.addEventListener('click', () => this.changeSliceCount(1));
                this.elements.sliceCount.addEventListener('change', () => this.updateSliceCount());

                // Slider controls
                this.setupSlider('bgGraySlider', 'bgGray', 'bgGrayValue', '%', (value) => this.updateBackgroundColor(value));
                this.setupSlider('offsetXSlider', 'offsetX', 'offsetXValue', '%', () => this.renderer.render());
                this.setupSlider('offsetYSlider', 'offsetY', 'offsetYValue', '%', () => this.renderer.render());
                this.setupSlider('radiusSlider', 'radius', 'radiusValue', '%', () => this.renderer.render());
                this.setupSlider('rotationSlider', 'rotation', 'rotationValue', 'Â°', () => this.renderer.updateRotation());
                this.setupSlider('gapSizeSlider', 'gapSize', 'gapSizeValue', 'Â°', () => this.renderer.render());
                this.setupSlider('gripThicknessSlider', 'gripThickness', 'gripThicknessValue', 'px', () => this.renderer.render());
                this.setupSlider('ticksPerEdgeSlider', 'ticksPerEdge', 'ticksPerEdgeValue', '', () => this.renderer.render());
                this.setupSlider('gripOpacitySlider', 'gripOpacity', 'gripOpacityValue', '%', () => this.renderer.render());
                this.setupSlider('gripRingOpacitySlider', 'gripRingOpacity', 'gripRingOpacityValue', '%', () => this.renderer.render());
                this.setupSlider('gripInsetSlider', 'gripInset', 'gripInsetValue', '%', () => this.renderer.render());
                this.setupSlider('pressShrinkSlider', 'pressShrink', 'pressShrinkValue', '%');
                this.setupSlider('pressBrightnessSlider', 'pressBrightness', 'pressBrightnessValue', '%');

                // Subscribe to rotation changes from interaction
                this.state.subscribe('rotation', (value) => {
                    this.elements.rotationSlider.value = Math.round(value);
                    this.elements.rotationValue.textContent = Math.round(value);
                    this.renderer.updateRotation();
                });

                // Subscribe to slice count changes from pinch gesture
                this.state.subscribe('sliceCount', (value) => {
                    this.elements.sliceCount.value = value;
                });
            }

            setupSlider(sliderKey, stateKey, valueKey, suffix, callback) {
                const slider = this.elements[sliderKey];
                const valueDisplay = this.elements[valueKey];

                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.state.set(stateKey, value);
                    const displayValue = value % 1 !== 0 ? value.toFixed(1) : value;
                    valueDisplay.textContent = displayValue + suffix;
                    if (callback) callback(value);
                });
            }

            changeSliceCount(delta) {
                const current = parseInt(this.elements.sliceCount.value);
                const newValue = Math.max(6, Math.min(72, current + delta));
                this.elements.sliceCount.value = newValue;
                this.updateSliceCount();
            }

            updateSliceCount() {
                const value = Math.max(6, Math.min(72, parseInt(this.elements.sliceCount.value)));
                this.elements.sliceCount.value = value;
                this.state.set('sliceCount', value);
                this.renderer.render();
            }

            updateBackgroundColor(value) {
                const grayValue = Math.round((value / 100) * 255);
                const hexValue = grayValue.toString(16).padStart(2, '0');
                document.documentElement.style.setProperty('--bg-primary', `#${hexValue}${hexValue}${hexValue}`);
                this.renderer.render();
            }

            toggleModal() {
                if (this.elements.modalBackdrop.classList.contains('active')) {
                    this.closeModal();
                } else {
                    this.openModal();
                }
            }

            openModal() {
                this.elements.modalBackdrop.classList.add('active');
                this.elements.toggleBtn.classList.add('active');
                this.elements.toggleBtn.setAttribute('aria-label', 'Close controls');
            }

            closeModal() {
                this.elements.modalBackdrop.classList.remove('active');
                this.elements.toggleBtn.classList.remove('active');
                this.elements.toggleBtn.setAttribute('aria-label', 'Open controls');
            }

            syncUIWithState() {
                const state = this.state.getAll();
                Object.keys(state).forEach(key => {
                    const sliderElement = this.elements[key + 'Slider'];
                    if (sliderElement) {
                        sliderElement.value = state[key];
                    }
                });
            }
        }

        // ============================================
        // APPLICATION
        // ============================================
        class Application {
            constructor() {
                this.svgElement = document.getElementById('pianoSvg');
                this.stateManager = new StateManager(INITIAL_STATE);
                this.geometryEngine = new GeometryEngine(this.stateManager);
                this.audioEngine = new AudioEngine();
                this.renderEngine = new RenderEngine(this.svgElement, this.stateManager, this.geometryEngine);
                this.interactionManager = null;
                this.controlsManager = null;
            }

            init() {
                // Initialize background color
                const grayValue = Math.round((this.stateManager.get('bgGray') / 100) * 255);
                const hexValue = grayValue.toString(16).padStart(2, '0');
                document.documentElement.style.setProperty('--bg-primary', `#${hexValue}${hexValue}${hexValue}`);

                // Initial render
                this.renderEngine.render();

                // Initialize managers
                this.interactionManager = new InteractionManager(
                    this.svgElement,
                    this.stateManager,
                    this.geometryEngine,
                    this.renderEngine,
                    this.audioEngine
                );

                this.controlsManager = new ControlsManager(this.stateManager, this.renderEngine);

                // Setup resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.stateManager.invalidateComputed();
                        this.renderEngine.render();
                    }, RESIZE_DEBOUNCE_MS);
                });

                // Add failsafe event listeners to prevent stuck notes
                window.addEventListener('blur', () => {
                    this.audioEngine.stopAllNotes();
                });

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.audioEngine.stopAllNotes();
                    }
                });

                // Add Escape key as panic button
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.audioEngine.stopAllNotes();
                    }
                });
            }
        }

        // ============================================
        // START APPLICATION
        // ============================================
        new Application().init();
    </script>
</body>
</html>
