<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Radial Piano – Ergonomics Prototype (Clamped)</title>
<style>
  :root{
    --bg: #fff;
    --slice: #111;
    --slice-pressed: #444;
    --press-scale: 0.96;
    --press-ms: 60ms;
    --release-ms: 240ms;
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0; background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow:hidden;
  }
  svg{ width:100vw; height:100vh; display:block; }
  .slice{
    fill: var(--slice);
    stroke: var(--bg);
    stroke-width: 2;
    cursor: pointer;
    transition:
      transform var(--release-ms) ease-out,
      fill var(--release-ms) ease-out;
  }
  .slice.pressed{
    fill: var(--slice-pressed);
    transform: scale(var(--press-scale));
    transition:
      transform var(--press-ms) ease-in,
      fill var(--press-ms) ease-in;
  }
</style>
</head>
<body>

<svg id="stage" role="application" aria-label="Radial ergonomic test"></svg>

<script>
  // =========================
  // Ergonomics-focused config
  // =========================
  const ERGO = {
    // Partial arc (deg). 0° = +X (to the right), positive = counter-clockwise.
    visibleSweepDeg: 150,
    visibleStartDeg: -10,

    // Touch band thickness (px)
    bandThicknessPx: 60,

    // Tiny gap between slices (deg)
    angularGapDeg: 0.6,

    // Thumb reach bias: bulge toward "up-right" for right hand
    reachBiasAmount: 0.14,       // 0..0.2 reasonable
    reachBiasDirectionDeg: 30,   // up-right
  };

  // Global slice system
  const STATE = {
    sliceCount: 24,
    rotationDeg: 0,
    // Base radius as % of min(viewport). Lower default so it’s visible even near corner:
    baseRadiusPercent: 62
  };

  // Margin to keep arcs off the very edge of the screen (px)
  const EDGE_MARGIN = 6;

  // ================
  // DOM + utilities
  // ================
  const SVG_NS = 'http://www.w3.org/2000/svg';
  const svg = document.getElementById('stage');

  function getViewport(){ return { w: window.innerWidth, h: window.innerHeight }; }
  function updateViewBox(){
    const {w,h} = getViewport();
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  }
  function degToRad(d){ return d * Math.PI / 180; }
  function normAngle(a){ let x=a%360; if(x<0) x+=360; return x; }

  // Bias factor peaks at reachBiasDirectionDeg, dips opposite
  function reachRadiusFactor(thetaDeg){
    const t = degToRad(thetaDeg - ERGO.reachBiasDirectionDeg);
    return 1 + ERGO.reachBiasAmount * Math.cos(t);
  }

  // Center for right-hand use: near bottom-right; adjust if you like
  function calculateCenter(){
    const {w,h} = getViewport();
    return { x: w * 0.88, y: h * 0.86 };
  }

  // Clamp radius so the point at angle theta stays inside the viewport (with margin)
  function maxRadiusToEdges(center, thetaDeg){
    const {w,h} = getViewport();
    const cx = center.x, cy = center.y;
    const t  = degToRad(thetaDeg);
    const c  = Math.cos(t), s = Math.sin(t);

    let limits = [];

    // Right edge (x <= w - margin)
    if (c >  1e-6) limits.push((w - EDGE_MARGIN - cx) / c);
    // Left edge  (x >= margin)
    if (c < -1e-6) limits.push((EDGE_MARGIN - cx) / c); // c is negative, result positive if feasible

    // Bottom edge (y <= h - margin)
    if (s >  1e-6) limits.push((h - EDGE_MARGIN - cy) / s);
    // Top edge    (y >= margin)
    if (s < -1e-6) limits.push((EDGE_MARGIN - cy) / s); // s negative

    // If direction is nearly parallel to an axis, those terms won’t contribute.
    // Take the minimum positive limit.
    limits = limits.filter(v => v > 0 && Number.isFinite(v));
    if (!limits.length) return Infinity;
    return Math.min(...limits);
  }

  // -------------------------
  // Geometry & slice drawing
  // -------------------------
  const dragState = { isDragging:false, pressed:new Set() };
  const sliceData = new Map(); // element -> {index,startAngle,endAngle}

  function render(){
    updateViewBox();
    svg.innerHTML = '';
    sliceData.clear();

    const { w, h } = getViewport();
    const baseDim = Math.min(w,h);
    const baseOuterR = (STATE.baseRadiusPercent / 100) * baseDim;
    const innerThickness = ERGO.bandThicknessPx;

    const center = calculateCenter();
    const anglePerSlice = 360 / STATE.sliceCount;
    const startWindow = ERGO.visibleStartDeg;
    const endWindow   = ERGO.visibleStartDeg + ERGO.visibleSweepDeg;

    const frag = document.createDocumentFragment();

    for(let i=0;i<STATE.sliceCount;i++){
      const startAngle = i * anglePerSlice + STATE.rotationDeg;
      const endAngle   = (i+1) * anglePerSlice + STATE.rotationDeg;

      // apply a tiny angular gap by shrinking each side
      const gap = ERGO.angularGapDeg * 0.5;
      const startA = startAngle + gap;
      const endA   = endAngle   - gap;
      const midA   = (startA + endA) * 0.5;

      // window test
      const inWindow = normAngle(midA - startWindow) <= ERGO.visibleSweepDeg;
      if(!inWindow) continue;

      // Desired (biased) outer radius
      const desiredOuter = baseOuterR * reachRadiusFactor(midA);
      // Hard cap so arc stays on-screen in that direction
      const maxOuter = maxRadiusToEdges(center, midA);
      const outerR = Math.max(8, Math.min(desiredOuter, maxOuter));
      const innerR = Math.max(outerR - innerThickness, 6);

      const sr = degToRad(startA);
      const er = degToRad(endA);

      // Outer arc endpoints
      const ox1 = center.x + outerR * Math.cos(sr);
      const oy1 = center.y + outerR * Math.sin(sr);
      const ox2 = center.x + outerR * Math.cos(er);
      const oy2 = center.y + outerR * Math.sin(er);

      // Inner arc endpoints (reverse to close ring)
      const ix2 = center.x + innerR * Math.cos(er);
      const iy2 = center.y + innerR * Math.sin(er);
      const ix1 = center.x + innerR * Math.cos(sr);
      const iy1 = center.y + innerR * Math.sin(sr);

      const sweepDeg = Math.abs(endA - startA);
      const largeArc = sweepDeg > 180 ? 1 : 0;

      const d = [
        `M ${ox1} ${oy1}`,
        `A ${outerR} ${outerR} 0 ${largeArc} 1 ${ox2} ${oy2}`,
        `L ${ix2} ${iy2}`,
        `A ${innerR} ${innerR} 0 ${largeArc} 0 ${ix1} ${iy1}`,
        `Z`
      ].join(' ');

      const path = document.createElementNS(SVG_NS, 'path');
      path.setAttribute('d', d);
      path.setAttribute('class','slice');
      path.setAttribute('data-slice', i);
      path.style.transformOrigin = `${center.x}px ${center.y}px`;

      sliceData.set(path, { index:i, startAngle:startA, endAngle:endA });
      attachPointerHandlers(path, i, startA, endA);
      frag.appendChild(path);
    }

    svg.appendChild(frag);
  }

  // ----------------
  // Pointer handling
  // ----------------
  function attachPointerHandlers(el, index, startAngle, endAngle){
    const press = () => { el.classList.add('pressed'); dragState.pressed.add(el); };
    const release = () => { el.classList.remove('pressed'); dragState.pressed.delete(el); };
    const trigger = () => handleSliceInteraction(index, startAngle, endAngle);

    el.addEventListener('pointerdown', (e)=>{
      el.setPointerCapture(e.pointerId);
      dragState.isDragging = true;
      press(); trigger();
    });
    el.addEventListener('pointerenter', ()=>{
      if(!dragState.isDragging) return;
      press(); trigger();
    });
    el.addEventListener('pointerleave', ()=>{
      if(!dragState.isDragging) return;
      release();
    });
    el.addEventListener('pointerup', ()=>{
      release();
      dragState.isDragging = false;
    });
  }

  function endDrag(){
    if(!dragState.isDragging) return;
    dragState.isDragging = false;
    dragState.pressed.forEach(el=>el.classList.remove('pressed'));
    dragState.pressed.clear();
  }
  document.addEventListener('pointerup', endDrag);
  document.addEventListener('pointercancel', endDrag);

  // No-op hook for now
  function handleSliceInteraction(index/*,startA,endA*/){
    // console.log('slice', index);
  }

  // ------------
  // Resize/debounce
  // ------------
  let rAF = null, needs = false;
  function scheduleRender(){
    if(rAF) { needs = true; return; }
    rAF = requestAnimationFrame(()=>{
      rAF = null;
      render();
      if(needs){ needs=false; scheduleRender(); }
    });
  }
  window.addEventListener('resize', scheduleRender);

  // Init
  render();
</script>
</body>
</html>
